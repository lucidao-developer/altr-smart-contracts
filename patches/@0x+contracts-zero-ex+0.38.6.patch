diff --git a/node_modules/@0x/contracts-zero-ex/contracts/src/external/FeeCollector.sol b/node_modules/@0x/contracts-zero-ex/contracts/src/external/FeeCollector.sol
index 0445265..bb7e61a 100644
--- a/node_modules/@0x/contracts-zero-ex/contracts/src/external/FeeCollector.sol
+++ b/node_modules/@0x/contracts-zero-ex/contracts/src/external/FeeCollector.sol
@@ -21,28 +21,28 @@ import "../vendor/v3/IStaking.sol";
 
 /// @dev The collector contract for protocol fees
 contract FeeCollector is AuthorizableV06 {
-    /// @dev Allow ether transfers to the collector.
-    receive() external payable {}
+	/// @dev Allow ether transfers to the collector.
+	receive() external payable {}
 
-    constructor() public {
-        _addAuthorizedAddress(msg.sender);
-    }
+	constructor() public {
+		_addAuthorizedAddress(msg.sender);
+	}
 
-    /// @dev   Approve the staking contract and join a pool. Only an authority
-    ///        can call this.
-    /// @param weth The WETH contract.
-    /// @param staking The staking contract.
-    /// @param poolId The pool ID this contract is collecting fees for.
-    function initialize(IEtherTokenV06 weth, IStaking staking, bytes32 poolId) external onlyAuthorized {
-        weth.approve(address(staking), type(uint256).max);
-        staking.joinStakingPoolAsMaker(poolId);
-    }
+	/// @dev   Approve the staking contract and join a pool. Only an authority
+	///        can call this.
+	/// @param weth The WETH contract.
+	/// @param staking The staking contract.
+	/// @param poolId The pool ID this contract is collecting fees for.
+	function initialize(IEtherTokenV06 weth, IStaking staking, bytes32 poolId) external onlyAuthorized {
+		weth.approve(address(staking), (2 ** 256 - 1));
+		staking.joinStakingPoolAsMaker(poolId);
+	}
 
-    /// @dev Convert all held ether to WETH. Only an authority can call this.
-    /// @param weth The WETH contract.
-    function convertToWeth(IEtherTokenV06 weth) external onlyAuthorized {
-        if (address(this).balance > 0) {
-            weth.deposit{value: address(this).balance}();
-        }
-    }
+	/// @dev Convert all held ether to WETH. Only an authority can call this.
+	/// @param weth The WETH contract.
+	function convertToWeth(IEtherTokenV06 weth) external onlyAuthorized {
+		if (address(this).balance > 0) {
+			weth.deposit{ value: address(this).balance }();
+		}
+	}
 }
diff --git a/node_modules/@0x/contracts-zero-ex/contracts/src/features/interfaces/INativeOrdersFeature.sol b/node_modules/@0x/contracts-zero-ex/contracts/src/features/interfaces/INativeOrdersFeature.sol
index 85b8c65..a405d80 100644
--- a/node_modules/@0x/contracts-zero-ex/contracts/src/features/interfaces/INativeOrdersFeature.sol
+++ b/node_modules/@0x/contracts-zero-ex/contracts/src/features/interfaces/INativeOrdersFeature.sol
@@ -22,350 +22,304 @@ import "./INativeOrdersEvents.sol";
 
 /// @dev Feature for interacting with limit orders.
 interface INativeOrdersFeature is INativeOrdersEvents {
-    /// @dev Transfers protocol fees from the `FeeCollector` pools into
-    ///      the staking contract.
-    /// @param poolIds Staking pool IDs
-    function transferProtocolFeesForPools(bytes32[] calldata poolIds) external;
-
-    /// @dev Fill a limit order. The taker and sender will be the caller.
-    /// @param order The limit order. ETH protocol fees can be
-    ///      attached to this call. Any unspent ETH will be refunded to
-    ///      the caller.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount Maximum taker token amount to fill this order with.
-    /// @return takerTokenFilledAmount How much maker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function fillLimitOrder(
-        LibNativeOrder.LimitOrder calldata order,
-        LibSignature.Signature calldata signature,
-        uint128 takerTokenFillAmount
-    ) external payable returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);
-
-    /// @dev Fill an RFQ order for up to `takerTokenFillAmount` taker tokens.
-    ///      The taker will be the caller.
-    /// @param order The RFQ order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount Maximum taker token amount to fill this order with.
-    /// @return takerTokenFilledAmount How much maker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function fillRfqOrder(
-        LibNativeOrder.RfqOrder calldata order,
-        LibSignature.Signature calldata signature,
-        uint128 takerTokenFillAmount
-    ) external returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);
-
-    /// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.
-    ///      The taker will be the caller. ETH protocol fees can be
-    ///      attached to this call. Any unspent ETH will be refunded to
-    ///      the caller.
-    /// @param order The limit order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount How much taker token to fill this order with.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function fillOrKillLimitOrder(
-        LibNativeOrder.LimitOrder calldata order,
-        LibSignature.Signature calldata signature,
-        uint128 takerTokenFillAmount
-    ) external payable returns (uint128 makerTokenFilledAmount);
-
-    /// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.
-    ///      The taker will be the caller.
-    /// @param order The RFQ order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount How much taker token to fill this order with.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function fillOrKillRfqOrder(
-        LibNativeOrder.RfqOrder calldata order,
-        LibSignature.Signature calldata signature,
-        uint128 takerTokenFillAmount
-    ) external returns (uint128 makerTokenFilledAmount);
-
-    /// @dev Fill a limit order. Internal variant. ETH protocol fees can be
-    ///      attached to this call. Any unspent ETH will be refunded to
-    ///      `msg.sender` (not `sender`).
-    /// @param order The limit order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount Maximum taker token to fill this order with.
-    /// @param taker The order taker.
-    /// @param sender The order sender.
-    /// @return takerTokenFilledAmount How much maker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function _fillLimitOrder(
-        LibNativeOrder.LimitOrder calldata order,
-        LibSignature.Signature calldata signature,
-        uint128 takerTokenFillAmount,
-        address taker,
-        address sender
-    ) external payable returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);
-
-    /// @dev Fill an RFQ order. Internal variant.
-    /// @param order The RFQ order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount Maximum taker token to fill this order with.
-    /// @param taker The order taker.
-    /// @param useSelfBalance Whether to use the ExchangeProxy's transient
-    ///        balance of taker tokens to fill the order.
-    /// @param recipient The recipient of the maker tokens.
-    /// @return takerTokenFilledAmount How much maker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function _fillRfqOrder(
-        LibNativeOrder.RfqOrder calldata order,
-        LibSignature.Signature calldata signature,
-        uint128 takerTokenFillAmount,
-        address taker,
-        bool useSelfBalance,
-        address recipient
-    ) external returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);
-
-    /// @dev Cancel a single limit order. The caller must be the maker or a valid order signer.
-    ///      Silently succeeds if the order has already been cancelled.
-    /// @param order The limit order.
-    function cancelLimitOrder(LibNativeOrder.LimitOrder calldata order) external;
-
-    /// @dev Cancel a single RFQ order. The caller must be the maker or a valid order signer.
-    ///      Silently succeeds if the order has already been cancelled.
-    /// @param order The RFQ order.
-    function cancelRfqOrder(LibNativeOrder.RfqOrder calldata order) external;
-
-    /// @dev Mark what tx.origin addresses are allowed to fill an order that
-    ///      specifies the message sender as its txOrigin.
-    /// @param origins An array of origin addresses to update.
-    /// @param allowed True to register, false to unregister.
-    function registerAllowedRfqOrigins(address[] memory origins, bool allowed) external;
-
-    /// @dev Cancel multiple limit orders. The caller must be the maker or a valid order signer.
-    ///      Silently succeeds if the order has already been cancelled.
-    /// @param orders The limit orders.
-    function batchCancelLimitOrders(LibNativeOrder.LimitOrder[] calldata orders) external;
-
-    /// @dev Cancel multiple RFQ orders. The caller must be the maker or a valid order signer.
-    ///      Silently succeeds if the order has already been cancelled.
-    /// @param orders The RFQ orders.
-    function batchCancelRfqOrders(LibNativeOrder.RfqOrder[] calldata orders) external;
-
-    /// @dev Cancel all limit orders for a given maker and pair with a salt less
-    ///      than the value provided. The caller must be the maker. Subsequent
-    ///      calls to this function with the same caller and pair require the
-    ///      new salt to be >= the old salt.
-    /// @param makerToken The maker token.
-    /// @param takerToken The taker token.
-    /// @param minValidSalt The new minimum valid salt.
-    function cancelPairLimitOrders(IERC20TokenV06 makerToken, IERC20TokenV06 takerToken, uint256 minValidSalt) external;
-
-    /// @dev Cancel all limit orders for a given maker and pair with a salt less
-    ///      than the value provided. The caller must be a signer registered to the maker.
-    ///      Subsequent calls to this function with the same maker and pair require the
-    ///      new salt to be >= the old salt.
-    /// @param maker The maker for which to cancel.
-    /// @param makerToken The maker token.
-    /// @param takerToken The taker token.
-    /// @param minValidSalt The new minimum valid salt.
-    function cancelPairLimitOrdersWithSigner(
-        address maker,
-        IERC20TokenV06 makerToken,
-        IERC20TokenV06 takerToken,
-        uint256 minValidSalt
-    ) external;
-
-    /// @dev Cancel all limit orders for a given maker and pairs with salts less
-    ///      than the values provided. The caller must be the maker. Subsequent
-    ///      calls to this function with the same caller and pair require the
-    ///      new salt to be >= the old salt.
-    /// @param makerTokens The maker tokens.
-    /// @param takerTokens The taker tokens.
-    /// @param minValidSalts The new minimum valid salts.
-    function batchCancelPairLimitOrders(
-        IERC20TokenV06[] calldata makerTokens,
-        IERC20TokenV06[] calldata takerTokens,
-        uint256[] calldata minValidSalts
-    ) external;
-
-    /// @dev Cancel all limit orders for a given maker and pairs with salts less
-    ///      than the values provided. The caller must be a signer registered to the maker.
-    ///      Subsequent calls to this function with the same maker and pair require the
-    ///      new salt to be >= the old salt.
-    /// @param maker The maker for which to cancel.
-    /// @param makerTokens The maker tokens.
-    /// @param takerTokens The taker tokens.
-    /// @param minValidSalts The new minimum valid salts.
-    function batchCancelPairLimitOrdersWithSigner(
-        address maker,
-        IERC20TokenV06[] memory makerTokens,
-        IERC20TokenV06[] memory takerTokens,
-        uint256[] memory minValidSalts
-    ) external;
-
-    /// @dev Cancel all RFQ orders for a given maker and pair with a salt less
-    ///      than the value provided. The caller must be the maker. Subsequent
-    ///      calls to this function with the same caller and pair require the
-    ///      new salt to be >= the old salt.
-    /// @param makerToken The maker token.
-    /// @param takerToken The taker token.
-    /// @param minValidSalt The new minimum valid salt.
-    function cancelPairRfqOrders(IERC20TokenV06 makerToken, IERC20TokenV06 takerToken, uint256 minValidSalt) external;
-
-    /// @dev Cancel all RFQ orders for a given maker and pair with a salt less
-    ///      than the value provided. The caller must be a signer registered to the maker.
-    ///      Subsequent calls to this function with the same maker and pair require the
-    ///      new salt to be >= the old salt.
-    /// @param maker The maker for which to cancel.
-    /// @param makerToken The maker token.
-    /// @param takerToken The taker token.
-    /// @param minValidSalt The new minimum valid salt.
-    function cancelPairRfqOrdersWithSigner(
-        address maker,
-        IERC20TokenV06 makerToken,
-        IERC20TokenV06 takerToken,
-        uint256 minValidSalt
-    ) external;
-
-    /// @dev Cancel all RFQ orders for a given maker and pairs with salts less
-    ///      than the values provided. The caller must be the maker. Subsequent
-    ///      calls to this function with the same caller and pair require the
-    ///      new salt to be >= the old salt.
-    /// @param makerTokens The maker tokens.
-    /// @param takerTokens The taker tokens.
-    /// @param minValidSalts The new minimum valid salts.
-    function batchCancelPairRfqOrders(
-        IERC20TokenV06[] calldata makerTokens,
-        IERC20TokenV06[] calldata takerTokens,
-        uint256[] calldata minValidSalts
-    ) external;
-
-    /// @dev Cancel all RFQ orders for a given maker and pairs with salts less
-    ///      than the values provided. The caller must be a signer registered to the maker.
-    ///      Subsequent calls to this function with the same maker and pair require the
-    ///      new salt to be >= the old salt.
-    /// @param maker The maker for which to cancel.
-    /// @param makerTokens The maker tokens.
-    /// @param takerTokens The taker tokens.
-    /// @param minValidSalts The new minimum valid salts.
-    function batchCancelPairRfqOrdersWithSigner(
-        address maker,
-        IERC20TokenV06[] memory makerTokens,
-        IERC20TokenV06[] memory takerTokens,
-        uint256[] memory minValidSalts
-    ) external;
-
-    /// @dev Get the order info for a limit order.
-    /// @param order The limit order.
-    /// @return orderInfo Info about the order.
-    function getLimitOrderInfo(
-        LibNativeOrder.LimitOrder calldata order
-    ) external view returns (LibNativeOrder.OrderInfo memory orderInfo);
-
-    /// @dev Get the order info for an RFQ order.
-    /// @param order The RFQ order.
-    /// @return orderInfo Info about the order.
-    function getRfqOrderInfo(
-        LibNativeOrder.RfqOrder calldata order
-    ) external view returns (LibNativeOrder.OrderInfo memory orderInfo);
-
-    /// @dev Get the canonical hash of a limit order.
-    /// @param order The limit order.
-    /// @return orderHash The order hash.
-    function getLimitOrderHash(LibNativeOrder.LimitOrder calldata order) external view returns (bytes32 orderHash);
-
-    /// @dev Get the canonical hash of an RFQ order.
-    /// @param order The RFQ order.
-    /// @return orderHash The order hash.
-    function getRfqOrderHash(LibNativeOrder.RfqOrder calldata order) external view returns (bytes32 orderHash);
-
-    /// @dev Get the protocol fee multiplier. This should be multiplied by the
-    ///      gas price to arrive at the required protocol fee to fill a native order.
-    /// @return multiplier The protocol fee multiplier.
-    function getProtocolFeeMultiplier() external view returns (uint32 multiplier);
-
-    /// @dev Get order info, fillable amount, and signature validity for a limit order.
-    ///      Fillable amount is determined using balances and allowances of the maker.
-    /// @param order The limit order.
-    /// @param signature The order signature.
-    /// @return orderInfo Info about the order.
-    /// @return actualFillableTakerTokenAmount How much of the order is fillable
-    ///         based on maker funds, in taker tokens.
-    /// @return isSignatureValid Whether the signature is valid.
-    function getLimitOrderRelevantState(
-        LibNativeOrder.LimitOrder calldata order,
-        LibSignature.Signature calldata signature
-    )
-        external
-        view
-        returns (
-            LibNativeOrder.OrderInfo memory orderInfo,
-            uint128 actualFillableTakerTokenAmount,
-            bool isSignatureValid
-        );
-
-    /// @dev Get order info, fillable amount, and signature validity for an RFQ order.
-    ///      Fillable amount is determined using balances and allowances of the maker.
-    /// @param order The RFQ order.
-    /// @param signature The order signature.
-    /// @return orderInfo Info about the order.
-    /// @return actualFillableTakerTokenAmount How much of the order is fillable
-    ///         based on maker funds, in taker tokens.
-    /// @return isSignatureValid Whether the signature is valid.
-    function getRfqOrderRelevantState(
-        LibNativeOrder.RfqOrder calldata order,
-        LibSignature.Signature calldata signature
-    )
-        external
-        view
-        returns (
-            LibNativeOrder.OrderInfo memory orderInfo,
-            uint128 actualFillableTakerTokenAmount,
-            bool isSignatureValid
-        );
-
-    /// @dev Batch version of `getLimitOrderRelevantState()`, without reverting.
-    ///      Orders that would normally cause `getLimitOrderRelevantState()`
-    ///      to revert will have empty results.
-    /// @param orders The limit orders.
-    /// @param signatures The order signatures.
-    /// @return orderInfos Info about the orders.
-    /// @return actualFillableTakerTokenAmounts How much of each order is fillable
-    ///         based on maker funds, in taker tokens.
-    /// @return isSignatureValids Whether each signature is valid for the order.
-    function batchGetLimitOrderRelevantStates(
-        LibNativeOrder.LimitOrder[] calldata orders,
-        LibSignature.Signature[] calldata signatures
-    )
-        external
-        view
-        returns (
-            LibNativeOrder.OrderInfo[] memory orderInfos,
-            uint128[] memory actualFillableTakerTokenAmounts,
-            bool[] memory isSignatureValids
-        );
-
-    /// @dev Batch version of `getRfqOrderRelevantState()`, without reverting.
-    ///      Orders that would normally cause `getRfqOrderRelevantState()`
-    ///      to revert will have empty results.
-    /// @param orders The RFQ orders.
-    /// @param signatures The order signatures.
-    /// @return orderInfos Info about the orders.
-    /// @return actualFillableTakerTokenAmounts How much of each order is fillable
-    ///         based on maker funds, in taker tokens.
-    /// @return isSignatureValids Whether each signature is valid for the order.
-    function batchGetRfqOrderRelevantStates(
-        LibNativeOrder.RfqOrder[] calldata orders,
-        LibSignature.Signature[] calldata signatures
-    )
-        external
-        view
-        returns (
-            LibNativeOrder.OrderInfo[] memory orderInfos,
-            uint128[] memory actualFillableTakerTokenAmounts,
-            bool[] memory isSignatureValids
-        );
-
-    /// @dev Register a signer who can sign on behalf of msg.sender
-    ///      This allows one to sign on behalf of a contract that calls this function
-    /// @param signer The address from which you plan to generate signatures
-    /// @param allowed True to register, false to unregister.
-    function registerAllowedOrderSigner(address signer, bool allowed) external;
-
-    /// @dev checks if a given address is registered to sign on behalf of a maker address
-    /// @param maker The maker address encoded in an order (can be a contract)
-    /// @param signer The address that is providing a signature
-    function isValidOrderSigner(address maker, address signer) external view returns (bool isAllowed);
+	/// @dev Transfers protocol fees from the `FeeCollector` pools into
+	///      the staking contract.
+	/// @param poolIds Staking pool IDs
+	function transferProtocolFeesForPools(bytes32[] calldata poolIds) external;
+
+	/// @dev Fill a limit order. The taker and sender will be the caller.
+	/// @param order The limit order. ETH protocol fees can be
+	///      attached to this call. Any unspent ETH will be refunded to
+	///      the caller.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount Maximum taker token amount to fill this order with.
+	/// @return takerTokenFilledAmount How much maker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function fillLimitOrder(
+		LibNativeOrder.LimitOrder calldata order,
+		LibSignature.Signature calldata signature,
+		uint128 takerTokenFillAmount
+	) external payable returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);
+
+	/// @dev Fill an RFQ order for up to `takerTokenFillAmount` taker tokens.
+	///      The taker will be the caller.
+	/// @param order The RFQ order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount Maximum taker token amount to fill this order with.
+	/// @return takerTokenFilledAmount How much maker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function fillRfqOrder(
+		LibNativeOrder.RfqOrder calldata order,
+		LibSignature.Signature calldata signature,
+		uint128 takerTokenFillAmount
+	) external returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);
+
+	/// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.
+	///      The taker will be the caller. ETH protocol fees can be
+	///      attached to this call. Any unspent ETH will be refunded to
+	///      the caller.
+	/// @param order The limit order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount How much taker token to fill this order with.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function fillOrKillLimitOrder(
+		LibNativeOrder.LimitOrder calldata order,
+		LibSignature.Signature calldata signature,
+		uint128 takerTokenFillAmount
+	) external payable returns (uint128 makerTokenFilledAmount);
+
+	/// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.
+	///      The taker will be the caller.
+	/// @param order The RFQ order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount How much taker token to fill this order with.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function fillOrKillRfqOrder(
+		LibNativeOrder.RfqOrder calldata order,
+		LibSignature.Signature calldata signature,
+		uint128 takerTokenFillAmount
+	) external returns (uint128 makerTokenFilledAmount);
+
+	/// @dev Fill a limit order. Internal variant. ETH protocol fees can be
+	///      attached to this call. Any unspent ETH will be refunded to
+	///      `msg.sender` (not `sender`).
+	/// @param order The limit order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount Maximum taker token to fill this order with.
+	/// @param taker The order taker.
+	/// @param sender The order sender.
+	/// @return takerTokenFilledAmount How much maker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function _fillLimitOrder(
+		LibNativeOrder.LimitOrder calldata order,
+		LibSignature.Signature calldata signature,
+		uint128 takerTokenFillAmount,
+		address taker,
+		address sender
+	) external payable returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);
+
+	/// @dev Fill an RFQ order. Internal variant.
+	/// @param order The RFQ order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount Maximum taker token to fill this order with.
+	/// @param taker The order taker.
+	/// @param useSelfBalance Whether to use the ExchangeProxy's transient
+	///        balance of taker tokens to fill the order.
+	/// @param recipient The recipient of the maker tokens.
+	/// @return takerTokenFilledAmount How much maker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function _fillRfqOrder(
+		LibNativeOrder.RfqOrder calldata order,
+		LibSignature.Signature calldata signature,
+		uint128 takerTokenFillAmount,
+		address taker,
+		bool useSelfBalance,
+		address recipient
+	) external returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);
+
+	/// @dev Cancel a single limit order. The caller must be the maker or a valid order signer.
+	///      Silently succeeds if the order has already been cancelled.
+	/// @param order The limit order.
+	function cancelLimitOrder(LibNativeOrder.LimitOrder calldata order) external;
+
+	/// @dev Cancel a single RFQ order. The caller must be the maker or a valid order signer.
+	///      Silently succeeds if the order has already been cancelled.
+	/// @param order The RFQ order.
+	function cancelRfqOrder(LibNativeOrder.RfqOrder calldata order) external;
+
+	/// @dev Mark what tx.origin addresses are allowed to fill an order that
+	///      specifies the message sender as its txOrigin.
+	/// @param origins An array of origin addresses to update.
+	/// @param allowed True to register, false to unregister.
+	function registerAllowedRfqOrigins(address[] calldata origins, bool allowed) external;
+
+	/// @dev Cancel multiple limit orders. The caller must be the maker or a valid order signer.
+	///      Silently succeeds if the order has already been cancelled.
+	/// @param orders The limit orders.
+	function batchCancelLimitOrders(LibNativeOrder.LimitOrder[] calldata orders) external;
+
+	/// @dev Cancel multiple RFQ orders. The caller must be the maker or a valid order signer.
+	///      Silently succeeds if the order has already been cancelled.
+	/// @param orders The RFQ orders.
+	function batchCancelRfqOrders(LibNativeOrder.RfqOrder[] calldata orders) external;
+
+	/// @dev Cancel all limit orders for a given maker and pair with a salt less
+	///      than the value provided. The caller must be the maker. Subsequent
+	///      calls to this function with the same caller and pair require the
+	///      new salt to be >= the old salt.
+	/// @param makerToken The maker token.
+	/// @param takerToken The taker token.
+	/// @param minValidSalt The new minimum valid salt.
+	function cancelPairLimitOrders(IERC20TokenV06 makerToken, IERC20TokenV06 takerToken, uint256 minValidSalt) external;
+
+	/// @dev Cancel all limit orders for a given maker and pair with a salt less
+	///      than the value provided. The caller must be a signer registered to the maker.
+	///      Subsequent calls to this function with the same maker and pair require the
+	///      new salt to be >= the old salt.
+	/// @param maker The maker for which to cancel.
+	/// @param makerToken The maker token.
+	/// @param takerToken The taker token.
+	/// @param minValidSalt The new minimum valid salt.
+	function cancelPairLimitOrdersWithSigner(address maker, IERC20TokenV06 makerToken, IERC20TokenV06 takerToken, uint256 minValidSalt) external;
+
+	/// @dev Cancel all limit orders for a given maker and pairs with salts less
+	///      than the values provided. The caller must be the maker. Subsequent
+	///      calls to this function with the same caller and pair require the
+	///      new salt to be >= the old salt.
+	/// @param makerTokens The maker tokens.
+	/// @param takerTokens The taker tokens.
+	/// @param minValidSalts The new minimum valid salts.
+	function batchCancelPairLimitOrders(
+		IERC20TokenV06[] calldata makerTokens,
+		IERC20TokenV06[] calldata takerTokens,
+		uint256[] calldata minValidSalts
+	) external;
+
+	/// @dev Cancel all limit orders for a given maker and pairs with salts less
+	///      than the values provided. The caller must be a signer registered to the maker.
+	///      Subsequent calls to this function with the same maker and pair require the
+	///      new salt to be >= the old salt.
+	/// @param maker The maker for which to cancel.
+	/// @param makerTokens The maker tokens.
+	/// @param takerTokens The taker tokens.
+	/// @param minValidSalts The new minimum valid salts.
+	function batchCancelPairLimitOrdersWithSigner(
+		address maker,
+		IERC20TokenV06[] calldata makerTokens,
+		IERC20TokenV06[] calldata takerTokens,
+		uint256[] calldata minValidSalts
+	) external;
+
+	/// @dev Cancel all RFQ orders for a given maker and pair with a salt less
+	///      than the value provided. The caller must be the maker. Subsequent
+	///      calls to this function with the same caller and pair require the
+	///      new salt to be >= the old salt.
+	/// @param makerToken The maker token.
+	/// @param takerToken The taker token.
+	/// @param minValidSalt The new minimum valid salt.
+	function cancelPairRfqOrders(IERC20TokenV06 makerToken, IERC20TokenV06 takerToken, uint256 minValidSalt) external;
+
+	/// @dev Cancel all RFQ orders for a given maker and pair with a salt less
+	///      than the value provided. The caller must be a signer registered to the maker.
+	///      Subsequent calls to this function with the same maker and pair require the
+	///      new salt to be >= the old salt.
+	/// @param maker The maker for which to cancel.
+	/// @param makerToken The maker token.
+	/// @param takerToken The taker token.
+	/// @param minValidSalt The new minimum valid salt.
+	function cancelPairRfqOrdersWithSigner(address maker, IERC20TokenV06 makerToken, IERC20TokenV06 takerToken, uint256 minValidSalt) external;
+
+	/// @dev Cancel all RFQ orders for a given maker and pairs with salts less
+	///      than the values provided. The caller must be the maker. Subsequent
+	///      calls to this function with the same caller and pair require the
+	///      new salt to be >= the old salt.
+	/// @param makerTokens The maker tokens.
+	/// @param takerTokens The taker tokens.
+	/// @param minValidSalts The new minimum valid salts.
+	function batchCancelPairRfqOrders(IERC20TokenV06[] calldata makerTokens, IERC20TokenV06[] calldata takerTokens, uint256[] calldata minValidSalts) external;
+
+	/// @dev Cancel all RFQ orders for a given maker and pairs with salts less
+	///      than the values provided. The caller must be a signer registered to the maker.
+	///      Subsequent calls to this function with the same maker and pair require the
+	///      new salt to be >= the old salt.
+	/// @param maker The maker for which to cancel.
+	/// @param makerTokens The maker tokens.
+	/// @param takerTokens The taker tokens.
+	/// @param minValidSalts The new minimum valid salts.
+	function batchCancelPairRfqOrdersWithSigner(
+		address maker,
+		IERC20TokenV06[] calldata makerTokens,
+		IERC20TokenV06[] calldata takerTokens,
+		uint256[] calldata minValidSalts
+	) external;
+
+	/// @dev Get the order info for a limit order.
+	/// @param order The limit order.
+	/// @return orderInfo Info about the order.
+	function getLimitOrderInfo(LibNativeOrder.LimitOrder calldata order) external view returns (LibNativeOrder.OrderInfo memory orderInfo);
+
+	/// @dev Get the order info for an RFQ order.
+	/// @param order The RFQ order.
+	/// @return orderInfo Info about the order.
+	function getRfqOrderInfo(LibNativeOrder.RfqOrder calldata order) external view returns (LibNativeOrder.OrderInfo memory orderInfo);
+
+	/// @dev Get the canonical hash of a limit order.
+	/// @param order The limit order.
+	/// @return orderHash The order hash.
+	function getLimitOrderHash(LibNativeOrder.LimitOrder calldata order) external view returns (bytes32 orderHash);
+
+	/// @dev Get the canonical hash of an RFQ order.
+	/// @param order The RFQ order.
+	/// @return orderHash The order hash.
+	function getRfqOrderHash(LibNativeOrder.RfqOrder calldata order) external view returns (bytes32 orderHash);
+
+	/// @dev Get the protocol fee multiplier. This should be multiplied by the
+	///      gas price to arrive at the required protocol fee to fill a native order.
+	/// @return multiplier The protocol fee multiplier.
+	function getProtocolFeeMultiplier() external view returns (uint32 multiplier);
+
+	/// @dev Get order info, fillable amount, and signature validity for a limit order.
+	///      Fillable amount is determined using balances and allowances of the maker.
+	/// @param order The limit order.
+	/// @param signature The order signature.
+	/// @return orderInfo Info about the order.
+	/// @return actualFillableTakerTokenAmount How much of the order is fillable
+	///         based on maker funds, in taker tokens.
+	/// @return isSignatureValid Whether the signature is valid.
+	function getLimitOrderRelevantState(
+		LibNativeOrder.LimitOrder calldata order,
+		LibSignature.Signature calldata signature
+	) external view returns (LibNativeOrder.OrderInfo memory orderInfo, uint128 actualFillableTakerTokenAmount, bool isSignatureValid);
+
+	/// @dev Get order info, fillable amount, and signature validity for an RFQ order.
+	///      Fillable amount is determined using balances and allowances of the maker.
+	/// @param order The RFQ order.
+	/// @param signature The order signature.
+	/// @return orderInfo Info about the order.
+	/// @return actualFillableTakerTokenAmount How much of the order is fillable
+	///         based on maker funds, in taker tokens.
+	/// @return isSignatureValid Whether the signature is valid.
+	function getRfqOrderRelevantState(
+		LibNativeOrder.RfqOrder calldata order,
+		LibSignature.Signature calldata signature
+	) external view returns (LibNativeOrder.OrderInfo memory orderInfo, uint128 actualFillableTakerTokenAmount, bool isSignatureValid);
+
+	/// @dev Batch version of `getLimitOrderRelevantState()`, without reverting.
+	///      Orders that would normally cause `getLimitOrderRelevantState()`
+	///      to revert will have empty results.
+	/// @param orders The limit orders.
+	/// @param signatures The order signatures.
+	/// @return orderInfos Info about the orders.
+	/// @return actualFillableTakerTokenAmounts How much of each order is fillable
+	///         based on maker funds, in taker tokens.
+	/// @return isSignatureValids Whether each signature is valid for the order.
+	function batchGetLimitOrderRelevantStates(
+		LibNativeOrder.LimitOrder[] calldata orders,
+		LibSignature.Signature[] calldata signatures
+	) external view returns (LibNativeOrder.OrderInfo[] memory orderInfos, uint128[] memory actualFillableTakerTokenAmounts, bool[] memory isSignatureValids);
+
+	/// @dev Batch version of `getRfqOrderRelevantState()`, without reverting.
+	///      Orders that would normally cause `getRfqOrderRelevantState()`
+	///      to revert will have empty results.
+	/// @param orders The RFQ orders.
+	/// @param signatures The order signatures.
+	/// @return orderInfos Info about the orders.
+	/// @return actualFillableTakerTokenAmounts How much of each order is fillable
+	///         based on maker funds, in taker tokens.
+	/// @return isSignatureValids Whether each signature is valid for the order.
+	function batchGetRfqOrderRelevantStates(
+		LibNativeOrder.RfqOrder[] calldata orders,
+		LibSignature.Signature[] calldata signatures
+	) external view returns (LibNativeOrder.OrderInfo[] memory orderInfos, uint128[] memory actualFillableTakerTokenAmounts, bool[] memory isSignatureValids);
+
+	/// @dev Register a signer who can sign on behalf of msg.sender
+	///      This allows one to sign on behalf of a contract that calls this function
+	/// @param signer The address from which you plan to generate signatures
+	/// @param allowed True to register, false to unregister.
+	function registerAllowedOrderSigner(address signer, bool allowed) external;
+
+	/// @dev checks if a given address is registered to sign on behalf of a maker address
+	/// @param maker The maker address encoded in an order (can be a contract)
+	/// @param signer The address that is providing a signature
+	function isValidOrderSigner(address maker, address signer) external view returns (bool isAllowed);
 }
diff --git a/node_modules/@0x/contracts-zero-ex/contracts/src/features/native_orders/NativeOrdersInfo.sol b/node_modules/@0x/contracts-zero-ex/contracts/src/features/native_orders/NativeOrdersInfo.sol
index 9207135..436818f 100644
--- a/node_modules/@0x/contracts-zero-ex/contracts/src/features/native_orders/NativeOrdersInfo.sol
+++ b/node_modules/@0x/contracts-zero-ex/contracts/src/features/native_orders/NativeOrdersInfo.sol
@@ -26,308 +26,261 @@ import "../libs/LibNativeOrder.sol";
 
 /// @dev Feature for getting info about limit and RFQ orders.
 abstract contract NativeOrdersInfo is FixinEIP712, FixinTokenSpender {
-    using LibSafeMathV06 for uint256;
-    using LibRichErrorsV06 for bytes;
+	using LibSafeMathV06 for uint256;
+	using LibRichErrorsV06 for bytes;
 
-    // @dev Params for `_getActualFillableTakerTokenAmount()`.
-    struct GetActualFillableTakerTokenAmountParams {
-        address maker;
-        IERC20TokenV06 makerToken;
-        uint128 orderMakerAmount;
-        uint128 orderTakerAmount;
-        LibNativeOrder.OrderInfo orderInfo;
-    }
+	// @dev Params for `_getActualFillableTakerTokenAmount()`.
+	struct GetActualFillableTakerTokenAmountParams {
+		address maker;
+		IERC20TokenV06 makerToken;
+		uint128 orderMakerAmount;
+		uint128 orderTakerAmount;
+		LibNativeOrder.OrderInfo orderInfo;
+	}
 
-    /// @dev Highest bit of a uint256, used to flag cancelled orders.
-    uint256 private constant HIGH_BIT = 1 << 255;
+	/// @dev Highest bit of a uint256, used to flag cancelled orders.
+	uint256 private constant HIGH_BIT = 1 << 255;
 
-    constructor(address zeroExAddress) internal FixinEIP712(zeroExAddress) {}
+	constructor(address zeroExAddress) internal FixinEIP712(zeroExAddress) {}
 
-    /// @dev Get the order info for a limit order.
-    /// @param order The limit order.
-    /// @return orderInfo Info about the order.
-    function getLimitOrderInfo(
-        LibNativeOrder.LimitOrder memory order
-    ) public view returns (LibNativeOrder.OrderInfo memory orderInfo) {
-        // Recover maker and compute order hash.
-        orderInfo.orderHash = getLimitOrderHash(order);
-        uint256 minValidSalt = LibNativeOrdersStorage
-            .getStorage()
-            .limitOrdersMakerToMakerTokenToTakerTokenToMinValidOrderSalt[order.maker][address(order.makerToken)][
-                address(order.takerToken)
-            ];
-        _populateCommonOrderInfoFields(orderInfo, order.takerAmount, order.expiry, order.salt, minValidSalt);
-    }
+	/// @dev Get the order info for a limit order.
+	/// @param order The limit order.
+	/// @return orderInfo Info about the order.
+	function getLimitOrderInfo(LibNativeOrder.LimitOrder memory order) public view returns (LibNativeOrder.OrderInfo memory orderInfo) {
+		// Recover maker and compute order hash.
+		orderInfo.orderHash = getLimitOrderHash(order);
+		uint256 minValidSalt = LibNativeOrdersStorage.getStorage().limitOrdersMakerToMakerTokenToTakerTokenToMinValidOrderSalt[order.maker][
+			address(order.makerToken)
+		][address(order.takerToken)];
+		_populateCommonOrderInfoFields(orderInfo, order.takerAmount, order.expiry, order.salt, minValidSalt);
+	}
 
-    /// @dev Get the order info for an RFQ order.
-    /// @param order The RFQ order.
-    /// @return orderInfo Info about the order.
-    function getRfqOrderInfo(
-        LibNativeOrder.RfqOrder memory order
-    ) public view returns (LibNativeOrder.OrderInfo memory orderInfo) {
-        // Recover maker and compute order hash.
-        orderInfo.orderHash = getRfqOrderHash(order);
-        uint256 minValidSalt = LibNativeOrdersStorage
-            .getStorage()
-            .rfqOrdersMakerToMakerTokenToTakerTokenToMinValidOrderSalt[order.maker][address(order.makerToken)][
-                address(order.takerToken)
-            ];
-        _populateCommonOrderInfoFields(orderInfo, order.takerAmount, order.expiry, order.salt, minValidSalt);
+	/// @dev Get the order info for an RFQ order.
+	/// @param order The RFQ order.
+	/// @return orderInfo Info about the order.
+	function getRfqOrderInfo(LibNativeOrder.RfqOrder memory order) public view returns (LibNativeOrder.OrderInfo memory orderInfo) {
+		// Recover maker and compute order hash.
+		orderInfo.orderHash = getRfqOrderHash(order);
+		uint256 minValidSalt = LibNativeOrdersStorage.getStorage().rfqOrdersMakerToMakerTokenToTakerTokenToMinValidOrderSalt[order.maker][
+			address(order.makerToken)
+		][address(order.takerToken)];
+		_populateCommonOrderInfoFields(orderInfo, order.takerAmount, order.expiry, order.salt, minValidSalt);
 
-        // Check for missing txOrigin.
-        if (order.txOrigin == address(0)) {
-            orderInfo.status = LibNativeOrder.OrderStatus.INVALID;
-        }
-    }
+		// Check for missing txOrigin.
+		if (order.txOrigin == address(0)) {
+			orderInfo.status = LibNativeOrder.OrderStatus.INVALID;
+		}
+	}
 
-    /// @dev Get the canonical hash of a limit order.
-    /// @param order The limit order.
-    /// @return orderHash The order hash.
-    function getLimitOrderHash(LibNativeOrder.LimitOrder memory order) public view returns (bytes32 orderHash) {
-        return _getEIP712Hash(LibNativeOrder.getLimitOrderStructHash(order));
-    }
+	/// @dev Get the canonical hash of a limit order.
+	/// @param order The limit order.
+	/// @return orderHash The order hash.
+	function getLimitOrderHash(LibNativeOrder.LimitOrder memory order) public view returns (bytes32 orderHash) {
+		return _getEIP712Hash(LibNativeOrder.getLimitOrderStructHash(order));
+	}
 
-    /// @dev Get the canonical hash of an RFQ order.
-    /// @param order The RFQ order.
-    /// @return orderHash The order hash.
-    function getRfqOrderHash(LibNativeOrder.RfqOrder memory order) public view returns (bytes32 orderHash) {
-        return _getEIP712Hash(LibNativeOrder.getRfqOrderStructHash(order));
-    }
+	/// @dev Get the canonical hash of an RFQ order.
+	/// @param order The RFQ order.
+	/// @return orderHash The order hash.
+	function getRfqOrderHash(LibNativeOrder.RfqOrder memory order) public view returns (bytes32 orderHash) {
+		return _getEIP712Hash(LibNativeOrder.getRfqOrderStructHash(order));
+	}
 
-    /// @dev Get order info, fillable amount, and signature validity for a limit order.
-    ///      Fillable amount is determined using balances and allowances of the maker.
-    /// @param order The limit order.
-    /// @param signature The order signature.
-    /// @return orderInfo Info about the order.
-    /// @return actualFillableTakerTokenAmount How much of the order is fillable
-    ///         based on maker funds, in taker tokens.
-    /// @return isSignatureValid Whether the signature is valid.
-    function getLimitOrderRelevantState(
-        LibNativeOrder.LimitOrder memory order,
-        LibSignature.Signature calldata signature
-    )
-        public
-        view
-        returns (
-            LibNativeOrder.OrderInfo memory orderInfo,
-            uint128 actualFillableTakerTokenAmount,
-            bool isSignatureValid
-        )
-    {
-        orderInfo = getLimitOrderInfo(order);
-        actualFillableTakerTokenAmount = _getActualFillableTakerTokenAmount(
-            GetActualFillableTakerTokenAmountParams({
-                maker: order.maker,
-                makerToken: order.makerToken,
-                orderMakerAmount: order.makerAmount,
-                orderTakerAmount: order.takerAmount,
-                orderInfo: orderInfo
-            })
-        );
-        address signerOfHash = LibSignature.getSignerOfHash(orderInfo.orderHash, signature);
-        isSignatureValid = (order.maker == signerOfHash) || isValidOrderSigner(order.maker, signerOfHash);
-    }
+	/// @dev Get order info, fillable amount, and signature validity for a limit order.
+	///      Fillable amount is determined using balances and allowances of the maker.
+	/// @param order The limit order.
+	/// @param signature The order signature.
+	/// @return orderInfo Info about the order.
+	/// @return actualFillableTakerTokenAmount How much of the order is fillable
+	///         based on maker funds, in taker tokens.
+	/// @return isSignatureValid Whether the signature is valid.
+	function getLimitOrderRelevantState(
+		LibNativeOrder.LimitOrder memory order,
+		LibSignature.Signature memory signature
+	) public view returns (LibNativeOrder.OrderInfo memory orderInfo, uint128 actualFillableTakerTokenAmount, bool isSignatureValid) {
+		orderInfo = getLimitOrderInfo(order);
+		actualFillableTakerTokenAmount = _getActualFillableTakerTokenAmount(
+			GetActualFillableTakerTokenAmountParams({
+				maker: order.maker,
+				makerToken: order.makerToken,
+				orderMakerAmount: order.makerAmount,
+				orderTakerAmount: order.takerAmount,
+				orderInfo: orderInfo
+			})
+		);
+		address signerOfHash = LibSignature.getSignerOfHash(orderInfo.orderHash, signature);
+		isSignatureValid = (order.maker == signerOfHash) || isValidOrderSigner(order.maker, signerOfHash);
+	}
 
-    /// @dev Get order info, fillable amount, and signature validity for an RFQ order.
-    ///      Fillable amount is determined using balances and allowances of the maker.
-    /// @param order The RFQ order.
-    /// @param signature The order signature.
-    /// @return orderInfo Info about the order.
-    /// @return actualFillableTakerTokenAmount How much of the order is fillable
-    ///         based on maker funds, in taker tokens.
-    /// @return isSignatureValid Whether the signature is valid.
-    function getRfqOrderRelevantState(
-        LibNativeOrder.RfqOrder memory order,
-        LibSignature.Signature memory signature
-    )
-        public
-        view
-        returns (
-            LibNativeOrder.OrderInfo memory orderInfo,
-            uint128 actualFillableTakerTokenAmount,
-            bool isSignatureValid
-        )
-    {
-        orderInfo = getRfqOrderInfo(order);
-        actualFillableTakerTokenAmount = _getActualFillableTakerTokenAmount(
-            GetActualFillableTakerTokenAmountParams({
-                maker: order.maker,
-                makerToken: order.makerToken,
-                orderMakerAmount: order.makerAmount,
-                orderTakerAmount: order.takerAmount,
-                orderInfo: orderInfo
-            })
-        );
-        address signerOfHash = LibSignature.getSignerOfHash(orderInfo.orderHash, signature);
-        isSignatureValid = (order.maker == signerOfHash) || isValidOrderSigner(order.maker, signerOfHash);
-    }
+	/// @dev Get order info, fillable amount, and signature validity for an RFQ order.
+	///      Fillable amount is determined using balances and allowances of the maker.
+	/// @param order The RFQ order.
+	/// @param signature The order signature.
+	/// @return orderInfo Info about the order.
+	/// @return actualFillableTakerTokenAmount How much of the order is fillable
+	///         based on maker funds, in taker tokens.
+	/// @return isSignatureValid Whether the signature is valid.
+	function getRfqOrderRelevantState(
+		LibNativeOrder.RfqOrder memory order,
+		LibSignature.Signature memory signature
+	) public view returns (LibNativeOrder.OrderInfo memory orderInfo, uint128 actualFillableTakerTokenAmount, bool isSignatureValid) {
+		orderInfo = getRfqOrderInfo(order);
+		actualFillableTakerTokenAmount = _getActualFillableTakerTokenAmount(
+			GetActualFillableTakerTokenAmountParams({
+				maker: order.maker,
+				makerToken: order.makerToken,
+				orderMakerAmount: order.makerAmount,
+				orderTakerAmount: order.takerAmount,
+				orderInfo: orderInfo
+			})
+		);
+		address signerOfHash = LibSignature.getSignerOfHash(orderInfo.orderHash, signature);
+		isSignatureValid = (order.maker == signerOfHash) || isValidOrderSigner(order.maker, signerOfHash);
+	}
 
-    /// @dev Batch version of `getLimitOrderRelevantState()`, without reverting.
-    ///      Orders that would normally cause `getLimitOrderRelevantState()`
-    ///      to revert will have empty results.
-    /// @param orders The limit orders.
-    /// @param signatures The order signatures.
-    /// @return orderInfos Info about the orders.
-    /// @return actualFillableTakerTokenAmounts How much of each order is fillable
-    ///         based on maker funds, in taker tokens.
-    /// @return isSignatureValids Whether each signature is valid for the order.
-    function batchGetLimitOrderRelevantStates(
-        LibNativeOrder.LimitOrder[] calldata orders,
-        LibSignature.Signature[] calldata signatures
-    )
-        external
-        view
-        returns (
-            LibNativeOrder.OrderInfo[] memory orderInfos,
-            uint128[] memory actualFillableTakerTokenAmounts,
-            bool[] memory isSignatureValids
-        )
-    {
-        require(orders.length == signatures.length, "NativeOrdersFeature/MISMATCHED_ARRAY_LENGTHS");
-        orderInfos = new LibNativeOrder.OrderInfo[](orders.length);
-        actualFillableTakerTokenAmounts = new uint128[](orders.length);
-        isSignatureValids = new bool[](orders.length);
-        for (uint256 i = 0; i < orders.length; ++i) {
-            try this.getLimitOrderRelevantState(orders[i], signatures[i]) returns (
-                LibNativeOrder.OrderInfo memory orderInfo,
-                uint128 actualFillableTakerTokenAmount,
-                bool isSignatureValid
-            ) {
-                orderInfos[i] = orderInfo;
-                actualFillableTakerTokenAmounts[i] = actualFillableTakerTokenAmount;
-                isSignatureValids[i] = isSignatureValid;
-            } catch {}
-        }
-    }
+	/// @dev Batch version of `getLimitOrderRelevantState()`, without reverting.
+	///      Orders that would normally cause `getLimitOrderRelevantState()`
+	///      to revert will have empty results.
+	/// @param orders The limit orders.
+	/// @param signatures The order signatures.
+	/// @return orderInfos Info about the orders.
+	/// @return actualFillableTakerTokenAmounts How much of each order is fillable
+	///         based on maker funds, in taker tokens.
+	/// @return isSignatureValids Whether each signature is valid for the order.
+	function batchGetLimitOrderRelevantStates(
+		LibNativeOrder.LimitOrder[] calldata orders,
+		LibSignature.Signature[] calldata signatures
+	) external view returns (LibNativeOrder.OrderInfo[] memory orderInfos, uint128[] memory actualFillableTakerTokenAmounts, bool[] memory isSignatureValids) {
+		require(orders.length == signatures.length, "NativeOrdersFeature/MISMATCHED_ARRAY_LENGTHS");
+		orderInfos = new LibNativeOrder.OrderInfo[](orders.length);
+		actualFillableTakerTokenAmounts = new uint128[](orders.length);
+		isSignatureValids = new bool[](orders.length);
+		for (uint256 i = 0; i < orders.length; ++i) {
+			try this.getLimitOrderRelevantState(orders[i], signatures[i]) returns (
+				LibNativeOrder.OrderInfo memory orderInfo,
+				uint128 actualFillableTakerTokenAmount,
+				bool isSignatureValid
+			) {
+				orderInfos[i] = orderInfo;
+				actualFillableTakerTokenAmounts[i] = actualFillableTakerTokenAmount;
+				isSignatureValids[i] = isSignatureValid;
+			} catch {}
+		}
+	}
 
-    /// @dev Batch version of `getRfqOrderRelevantState()`, without reverting.
-    ///      Orders that would normally cause `getRfqOrderRelevantState()`
-    ///      to revert will have empty results.
-    /// @param orders The RFQ orders.
-    /// @param signatures The order signatures.
-    /// @return orderInfos Info about the orders.
-    /// @return actualFillableTakerTokenAmounts How much of each order is fillable
-    ///         based on maker funds, in taker tokens.
-    /// @return isSignatureValids Whether each signature is valid for the order.
-    function batchGetRfqOrderRelevantStates(
-        LibNativeOrder.RfqOrder[] calldata orders,
-        LibSignature.Signature[] calldata signatures
-    )
-        external
-        view
-        returns (
-            LibNativeOrder.OrderInfo[] memory orderInfos,
-            uint128[] memory actualFillableTakerTokenAmounts,
-            bool[] memory isSignatureValids
-        )
-    {
-        require(orders.length == signatures.length, "NativeOrdersFeature/MISMATCHED_ARRAY_LENGTHS");
-        orderInfos = new LibNativeOrder.OrderInfo[](orders.length);
-        actualFillableTakerTokenAmounts = new uint128[](orders.length);
-        isSignatureValids = new bool[](orders.length);
-        for (uint256 i = 0; i < orders.length; ++i) {
-            try this.getRfqOrderRelevantState(orders[i], signatures[i]) returns (
-                LibNativeOrder.OrderInfo memory orderInfo,
-                uint128 actualFillableTakerTokenAmount,
-                bool isSignatureValid
-            ) {
-                orderInfos[i] = orderInfo;
-                actualFillableTakerTokenAmounts[i] = actualFillableTakerTokenAmount;
-                isSignatureValids[i] = isSignatureValid;
-            } catch {}
-        }
-    }
+	/// @dev Batch version of `getRfqOrderRelevantState()`, without reverting.
+	///      Orders that would normally cause `getRfqOrderRelevantState()`
+	///      to revert will have empty results.
+	/// @param orders The RFQ orders.
+	/// @param signatures The order signatures.
+	/// @return orderInfos Info about the orders.
+	/// @return actualFillableTakerTokenAmounts How much of each order is fillable
+	///         based on maker funds, in taker tokens.
+	/// @return isSignatureValids Whether each signature is valid for the order.
+	function batchGetRfqOrderRelevantStates(
+		LibNativeOrder.RfqOrder[] calldata orders,
+		LibSignature.Signature[] calldata signatures
+	) external view returns (LibNativeOrder.OrderInfo[] memory orderInfos, uint128[] memory actualFillableTakerTokenAmounts, bool[] memory isSignatureValids) {
+		require(orders.length == signatures.length, "NativeOrdersFeature/MISMATCHED_ARRAY_LENGTHS");
+		orderInfos = new LibNativeOrder.OrderInfo[](orders.length);
+		actualFillableTakerTokenAmounts = new uint128[](orders.length);
+		isSignatureValids = new bool[](orders.length);
+		for (uint256 i = 0; i < orders.length; ++i) {
+			try this.getRfqOrderRelevantState(orders[i], signatures[i]) returns (
+				LibNativeOrder.OrderInfo memory orderInfo,
+				uint128 actualFillableTakerTokenAmount,
+				bool isSignatureValid
+			) {
+				orderInfos[i] = orderInfo;
+				actualFillableTakerTokenAmounts[i] = actualFillableTakerTokenAmount;
+				isSignatureValids[i] = isSignatureValid;
+			} catch {}
+		}
+	}
 
-    /// @dev Populate `status` and `takerTokenFilledAmount` fields in
-    ///      `orderInfo`, which use the same code path for both limit and
-    ///      RFQ orders.
-    /// @param orderInfo `OrderInfo` with `orderHash` and `maker` filled.
-    /// @param takerAmount The order's taker token amount..
-    /// @param expiry The order's expiry.
-    /// @param salt The order's salt.
-    /// @param salt The minimum valid salt for the maker and pair combination.
-    function _populateCommonOrderInfoFields(
-        LibNativeOrder.OrderInfo memory orderInfo,
-        uint128 takerAmount,
-        uint64 expiry,
-        uint256 salt,
-        uint256 minValidSalt
-    ) private view {
-        LibNativeOrdersStorage.Storage storage stor = LibNativeOrdersStorage.getStorage();
+	/// @dev Populate `status` and `takerTokenFilledAmount` fields in
+	///      `orderInfo`, which use the same code path for both limit and
+	///      RFQ orders.
+	/// @param orderInfo `OrderInfo` with `orderHash` and `maker` filled.
+	/// @param takerAmount The order's taker token amount..
+	/// @param expiry The order's expiry.
+	/// @param salt The order's salt.
+	/// @param salt The minimum valid salt for the maker and pair combination.
+	function _populateCommonOrderInfoFields(
+		LibNativeOrder.OrderInfo memory orderInfo,
+		uint128 takerAmount,
+		uint64 expiry,
+		uint256 salt,
+		uint256 minValidSalt
+	) private view {
+		LibNativeOrdersStorage.Storage storage stor = LibNativeOrdersStorage.getStorage();
 
-        // Get the filled and direct cancel state.
-        {
-            // The high bit of the raw taker token filled amount will be set
-            // if the order was cancelled.
-            uint256 rawTakerTokenFilledAmount = stor.orderHashToTakerTokenFilledAmount[orderInfo.orderHash];
-            orderInfo.takerTokenFilledAmount = uint128(rawTakerTokenFilledAmount);
-            if (orderInfo.takerTokenFilledAmount >= takerAmount) {
-                orderInfo.status = LibNativeOrder.OrderStatus.FILLED;
-                return;
-            }
-            if (rawTakerTokenFilledAmount & HIGH_BIT != 0) {
-                orderInfo.status = LibNativeOrder.OrderStatus.CANCELLED;
-                return;
-            }
-        }
+		// Get the filled and direct cancel state.
+		{
+			// The high bit of the raw taker token filled amount will be set
+			// if the order was cancelled.
+			uint256 rawTakerTokenFilledAmount = stor.orderHashToTakerTokenFilledAmount[orderInfo.orderHash];
+			orderInfo.takerTokenFilledAmount = uint128(rawTakerTokenFilledAmount);
+			if (orderInfo.takerTokenFilledAmount >= takerAmount) {
+				orderInfo.status = LibNativeOrder.OrderStatus.FILLED;
+				return;
+			}
+			if (rawTakerTokenFilledAmount & HIGH_BIT != 0) {
+				orderInfo.status = LibNativeOrder.OrderStatus.CANCELLED;
+				return;
+			}
+		}
 
-        // Check for expiration.
-        if (expiry <= uint64(block.timestamp)) {
-            orderInfo.status = LibNativeOrder.OrderStatus.EXPIRED;
-            return;
-        }
+		// Check for expiration.
+		if (expiry <= uint64(block.timestamp)) {
+			orderInfo.status = LibNativeOrder.OrderStatus.EXPIRED;
+			return;
+		}
 
-        // Check if the order was cancelled by salt.
-        if (minValidSalt > salt) {
-            orderInfo.status = LibNativeOrder.OrderStatus.CANCELLED;
-            return;
-        }
-        orderInfo.status = LibNativeOrder.OrderStatus.FILLABLE;
-    }
+		// Check if the order was cancelled by salt.
+		if (minValidSalt > salt) {
+			orderInfo.status = LibNativeOrder.OrderStatus.CANCELLED;
+			return;
+		}
+		orderInfo.status = LibNativeOrder.OrderStatus.FILLABLE;
+	}
 
-    /// @dev Calculate the actual fillable taker token amount of an order
-    ///      based on maker allowance and balances.
-    function _getActualFillableTakerTokenAmount(
-        GetActualFillableTakerTokenAmountParams memory params
-    ) private view returns (uint128 actualFillableTakerTokenAmount) {
-        if (params.orderMakerAmount == 0 || params.orderTakerAmount == 0) {
-            // Empty order.
-            return 0;
-        }
-        if (params.orderInfo.status != LibNativeOrder.OrderStatus.FILLABLE) {
-            // Not fillable.
-            return 0;
-        }
+	/// @dev Calculate the actual fillable taker token amount of an order
+	///      based on maker allowance and balances.
+	function _getActualFillableTakerTokenAmount(
+		GetActualFillableTakerTokenAmountParams memory params
+	) private view returns (uint128 actualFillableTakerTokenAmount) {
+		if (params.orderMakerAmount == 0 || params.orderTakerAmount == 0) {
+			// Empty order.
+			return 0;
+		}
+		if (params.orderInfo.status != LibNativeOrder.OrderStatus.FILLABLE) {
+			// Not fillable.
+			return 0;
+		}
 
-        // Get the fillable maker amount based on the order quantities and
-        // previously filled amount
-        uint256 fillableMakerTokenAmount = LibMathV06.getPartialAmountFloor(
-            uint256(params.orderTakerAmount - params.orderInfo.takerTokenFilledAmount),
-            uint256(params.orderTakerAmount),
-            uint256(params.orderMakerAmount)
-        );
-        // Clamp it to the amount of maker tokens we can spend on behalf of the
-        // maker.
-        fillableMakerTokenAmount = LibSafeMathV06.min256(
-            fillableMakerTokenAmount,
-            _getSpendableERC20BalanceOf(params.makerToken, params.maker)
-        );
-        // Convert to taker token amount.
-        return
-            LibMathV06
-                .getPartialAmountCeil(
-                    fillableMakerTokenAmount,
-                    uint256(params.orderMakerAmount),
-                    uint256(params.orderTakerAmount)
-                )
-                .safeDowncastToUint128();
-    }
+		// Get the fillable maker amount based on the order quantities and
+		// previously filled amount
+		uint256 fillableMakerTokenAmount = LibMathV06.getPartialAmountFloor(
+			uint256(params.orderTakerAmount - params.orderInfo.takerTokenFilledAmount),
+			uint256(params.orderTakerAmount),
+			uint256(params.orderMakerAmount)
+		);
+		// Clamp it to the amount of maker tokens we can spend on behalf of the
+		// maker.
+		fillableMakerTokenAmount = LibSafeMathV06.min256(fillableMakerTokenAmount, _getSpendableERC20BalanceOf(params.makerToken, params.maker));
+		// Convert to taker token amount.
+		return
+			LibMathV06
+				.getPartialAmountCeil(fillableMakerTokenAmount, uint256(params.orderMakerAmount), uint256(params.orderTakerAmount))
+				.safeDowncastToUint128();
+	}
 
-    /// @dev checks if a given address is registered to sign on behalf of a maker address
-    /// @param maker The maker address encoded in an order (can be a contract)
-    /// @param signer The address that is providing a signature
-    function isValidOrderSigner(address maker, address signer) public view returns (bool isValid) {
-        // returns false if it the mapping doesn't exist
-        return LibNativeOrdersStorage.getStorage().orderSignerRegistry[maker][signer];
-    }
+	/// @dev checks if a given address is registered to sign on behalf of a maker address
+	/// @param maker The maker address encoded in an order (can be a contract)
+	/// @param signer The address that is providing a signature
+	function isValidOrderSigner(address maker, address signer) public view returns (bool isValid) {
+		// returns false if it the mapping doesn't exist
+		return LibNativeOrdersStorage.getStorage().orderSignerRegistry[maker][signer];
+	}
 }
diff --git a/node_modules/@0x/contracts-zero-ex/contracts/src/features/native_orders/NativeOrdersSettlement.sol b/node_modules/@0x/contracts-zero-ex/contracts/src/features/native_orders/NativeOrdersSettlement.sol
index 164281e..20341a1 100644
--- a/node_modules/@0x/contracts-zero-ex/contracts/src/features/native_orders/NativeOrdersSettlement.sol
+++ b/node_modules/@0x/contracts-zero-ex/contracts/src/features/native_orders/NativeOrdersSettlement.sol
@@ -31,491 +31,430 @@ import "./NativeOrdersCancellation.sol";
 import "./NativeOrdersProtocolFees.sol";
 
 /// @dev Mixin for settling limit and RFQ orders.
-abstract contract NativeOrdersSettlement is
-    INativeOrdersEvents,
-    NativeOrdersCancellation,
-    NativeOrdersProtocolFees,
-    FixinCommon
-{
-    using LibSafeMathV06 for uint128;
-    using LibRichErrorsV06 for bytes;
-
-    /// @dev Params for `_settleOrder()`.
-    struct SettleOrderInfo {
-        // Order hash.
-        bytes32 orderHash;
-        // Maker of the order.
-        address maker;
-        // The address holding the taker tokens.
-        address payer;
-        // Recipient of the maker tokens.
-        address recipient;
-        // Maker token.
-        IERC20TokenV06 makerToken;
-        // Taker token.
-        IERC20TokenV06 takerToken;
-        // Maker token amount.
-        uint128 makerAmount;
-        // Taker token amount.
-        uint128 takerAmount;
-        // Maximum taker token amount to fill.
-        uint128 takerTokenFillAmount;
-        // How much taker token amount has already been filled in this order.
-        uint128 takerTokenFilledAmount;
-    }
-
-    /// @dev Params for `_fillLimitOrderPrivate()`
-    struct FillLimitOrderPrivateParams {
-        // The limit order.
-        LibNativeOrder.LimitOrder order;
-        // The order signature.
-        LibSignature.Signature signature;
-        // Maximum taker token to fill this order with.
-        uint128 takerTokenFillAmount;
-        // The order taker.
-        address taker;
-        // The order sender.
-        address sender;
-    }
-
-    /// @dev Params for `_fillRfqOrderPrivate()`
-    struct FillRfqOrderPrivateParams {
-        LibNativeOrder.RfqOrder order;
-        // The order signature.
-        LibSignature.Signature signature;
-        // Maximum taker token to fill this order with.
-        uint128 takerTokenFillAmount;
-        // The order taker.
-        address taker;
-        // Whether to use the Exchange Proxy's balance
-        // of taker tokens.
-        bool useSelfBalance;
-        // The recipient of the maker tokens.
-        address recipient;
-    }
-
-    // @dev Fill results returned by `_fillLimitOrderPrivate()` and
-    ///     `_fillRfqOrderPrivate()`.
-    struct FillNativeOrderResults {
-        uint256 ethProtocolFeePaid;
-        uint128 takerTokenFilledAmount;
-        uint128 makerTokenFilledAmount;
-        uint128 takerTokenFeeFilledAmount;
-    }
-
-    constructor(
-        address zeroExAddress,
-        IEtherTokenV06 weth,
-        IStaking staking,
-        FeeCollectorController feeCollectorController,
-        uint32 protocolFeeMultiplier
-    )
-        public
-        NativeOrdersCancellation(zeroExAddress)
-        NativeOrdersProtocolFees(weth, staking, feeCollectorController, protocolFeeMultiplier)
-    {}
-
-    /// @dev Fill a limit order. The taker and sender will be the caller.
-    /// @param order The limit order. ETH protocol fees can be
-    ///      attached to this call. Any unspent ETH will be refunded to
-    ///      the caller.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount Maximum taker token amount to fill this order with.
-    /// @return takerTokenFilledAmount How much maker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function fillLimitOrder(
-        LibNativeOrder.LimitOrder memory order,
-        LibSignature.Signature memory signature,
-        uint128 takerTokenFillAmount
-    ) public payable returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
-        FillNativeOrderResults memory results = _fillLimitOrderPrivate(
-            FillLimitOrderPrivateParams({
-                order: order,
-                signature: signature,
-                takerTokenFillAmount: takerTokenFillAmount,
-                taker: msg.sender,
-                sender: msg.sender
-            })
-        );
-        LibNativeOrder.refundExcessProtocolFeeToSender(results.ethProtocolFeePaid);
-        (takerTokenFilledAmount, makerTokenFilledAmount) = (
-            results.takerTokenFilledAmount,
-            results.makerTokenFilledAmount
-        );
-    }
-
-    /// @dev Fill an RFQ order for up to `takerTokenFillAmount` taker tokens.
-    ///      The taker will be the caller. ETH should be attached to pay the
-    ///      protocol fee.
-    /// @param order The RFQ order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount Maximum taker token amount to fill this order with.
-    /// @return takerTokenFilledAmount How much maker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function fillRfqOrder(
-        LibNativeOrder.RfqOrder memory order,
-        LibSignature.Signature memory signature,
-        uint128 takerTokenFillAmount
-    ) public returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
-        FillNativeOrderResults memory results = _fillRfqOrderPrivate(
-            FillRfqOrderPrivateParams({
-                order: order,
-                signature: signature,
-                takerTokenFillAmount: takerTokenFillAmount,
-                taker: msg.sender,
-                useSelfBalance: false,
-                recipient: msg.sender
-            })
-        );
-        (takerTokenFilledAmount, makerTokenFilledAmount) = (
-            results.takerTokenFilledAmount,
-            results.makerTokenFilledAmount
-        );
-    }
-
-    /// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.
-    ///      The taker will be the caller. ETH protocol fees can be
-    ///      attached to this call. Any unspent ETH will be refunded to
-    ///      the caller.
-    /// @param order The limit order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount How much taker token to fill this order with.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function fillOrKillLimitOrder(
-        LibNativeOrder.LimitOrder memory order,
-        LibSignature.Signature memory signature,
-        uint128 takerTokenFillAmount
-    ) public payable returns (uint128 makerTokenFilledAmount) {
-        FillNativeOrderResults memory results = _fillLimitOrderPrivate(
-            FillLimitOrderPrivateParams({
-                order: order,
-                signature: signature,
-                takerTokenFillAmount: takerTokenFillAmount,
-                taker: msg.sender,
-                sender: msg.sender
-            })
-        );
-        // Must have filled exactly the amount requested.
-        if (results.takerTokenFilledAmount < takerTokenFillAmount) {
-            LibNativeOrdersRichErrors
-                .FillOrKillFailedError(getLimitOrderHash(order), results.takerTokenFilledAmount, takerTokenFillAmount)
-                .rrevert();
-        }
-        LibNativeOrder.refundExcessProtocolFeeToSender(results.ethProtocolFeePaid);
-        makerTokenFilledAmount = results.makerTokenFilledAmount;
-    }
-
-    /// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.
-    ///      The taker will be the caller. ETH protocol fees can be
-    ///      attached to this call. Any unspent ETH will be refunded to
-    ///      the caller.
-    /// @param order The RFQ order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount How much taker token to fill this order with.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function fillOrKillRfqOrder(
-        LibNativeOrder.RfqOrder memory order,
-        LibSignature.Signature memory signature,
-        uint128 takerTokenFillAmount
-    ) public returns (uint128 makerTokenFilledAmount) {
-        FillNativeOrderResults memory results = _fillRfqOrderPrivate(
-            FillRfqOrderPrivateParams({
-                order: order,
-                signature: signature,
-                takerTokenFillAmount: takerTokenFillAmount,
-                taker: msg.sender,
-                useSelfBalance: false,
-                recipient: msg.sender
-            })
-        );
-        // Must have filled exactly the amount requested.
-        if (results.takerTokenFilledAmount < takerTokenFillAmount) {
-            LibNativeOrdersRichErrors
-                .FillOrKillFailedError(getRfqOrderHash(order), results.takerTokenFilledAmount, takerTokenFillAmount)
-                .rrevert();
-        }
-        makerTokenFilledAmount = results.makerTokenFilledAmount;
-    }
-
-    /// @dev Fill a limit order. Internal variant. ETH protocol fees can be
-    ///      attached to this call.
-    /// @param order The limit order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount Maximum taker token to fill this order with.
-    /// @param taker The order taker.
-    /// @param sender The order sender.
-    /// @return takerTokenFilledAmount How much maker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function _fillLimitOrder(
-        LibNativeOrder.LimitOrder memory order,
-        LibSignature.Signature memory signature,
-        uint128 takerTokenFillAmount,
-        address taker,
-        address sender
-    ) public payable virtual onlySelf returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
-        FillNativeOrderResults memory results = _fillLimitOrderPrivate(
-            FillLimitOrderPrivateParams(order, signature, takerTokenFillAmount, taker, sender)
-        );
-        (takerTokenFilledAmount, makerTokenFilledAmount) = (
-            results.takerTokenFilledAmount,
-            results.makerTokenFilledAmount
-        );
-    }
-
-    /// @dev Fill an RFQ order. Internal variant.
-    /// @param order The RFQ order.
-    /// @param signature The order signature.
-    /// @param takerTokenFillAmount Maximum taker token to fill this order with.
-    /// @param taker The order taker.
-    /// @param useSelfBalance Whether to use the ExchangeProxy's transient
-    ///        balance of taker tokens to fill the order.
-    /// @param recipient The recipient of the maker tokens.
-    /// @return takerTokenFilledAmount How much maker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function _fillRfqOrder(
-        LibNativeOrder.RfqOrder memory order,
-        LibSignature.Signature memory signature,
-        uint128 takerTokenFillAmount,
-        address taker,
-        bool useSelfBalance,
-        address recipient
-    ) public virtual onlySelf returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
-        FillNativeOrderResults memory results = _fillRfqOrderPrivate(
-            FillRfqOrderPrivateParams(order, signature, takerTokenFillAmount, taker, useSelfBalance, recipient)
-        );
-        (takerTokenFilledAmount, makerTokenFilledAmount) = (
-            results.takerTokenFilledAmount,
-            results.makerTokenFilledAmount
-        );
-    }
-
-    /// @dev Mark what tx.origin addresses are allowed to fill an order that
-    ///      specifies the message sender as its txOrigin.
-    /// @param origins An array of origin addresses to update.
-    /// @param allowed True to register, false to unregister.
-    function registerAllowedRfqOrigins(address[] memory origins, bool allowed) external {
-        require(msg.sender == tx.origin, "NativeOrdersFeature/NO_CONTRACT_ORIGINS");
-
-        LibNativeOrdersStorage.Storage storage stor = LibNativeOrdersStorage.getStorage();
-
-        for (uint256 i = 0; i < origins.length; i++) {
-            stor.originRegistry[msg.sender][origins[i]] = allowed;
-        }
-
-        emit RfqOrderOriginsAllowed(msg.sender, origins, allowed);
-    }
-
-    /// @dev Fill a limit order. Private variant. Does not refund protocol fees.
-    /// @param params Function params.
-    /// @return results Results of the fill.
-    function _fillLimitOrderPrivate(
-        FillLimitOrderPrivateParams memory params
-    ) private returns (FillNativeOrderResults memory results) {
-        LibNativeOrder.OrderInfo memory orderInfo = getLimitOrderInfo(params.order);
-
-        // Must be fillable.
-        if (orderInfo.status != LibNativeOrder.OrderStatus.FILLABLE) {
-            LibNativeOrdersRichErrors.OrderNotFillableError(orderInfo.orderHash, uint8(orderInfo.status)).rrevert();
-        }
-
-        // Must be fillable by the taker.
-        if (params.order.taker != address(0) && params.order.taker != params.taker) {
-            LibNativeOrdersRichErrors
-                .OrderNotFillableByTakerError(orderInfo.orderHash, params.taker, params.order.taker)
-                .rrevert();
-        }
-
-        // Must be fillable by the sender.
-        if (params.order.sender != address(0) && params.order.sender != params.sender) {
-            LibNativeOrdersRichErrors
-                .OrderNotFillableBySenderError(orderInfo.orderHash, params.sender, params.order.sender)
-                .rrevert();
-        }
-
-        // Signature must be valid for the order.
-        {
-            address signer = LibSignature.getSignerOfHash(orderInfo.orderHash, params.signature);
-            if (signer != params.order.maker && !isValidOrderSigner(params.order.maker, signer)) {
-                LibNativeOrdersRichErrors
-                    .OrderNotSignedByMakerError(orderInfo.orderHash, signer, params.order.maker)
-                    .rrevert();
-            }
-        }
-
-        // Pay the protocol fee.
-        results.ethProtocolFeePaid = _collectProtocolFee(params.order.pool);
-
-        // Settle between the maker and taker.
-        (results.takerTokenFilledAmount, results.makerTokenFilledAmount) = _settleOrder(
-            SettleOrderInfo({
-                orderHash: orderInfo.orderHash,
-                maker: params.order.maker,
-                payer: params.taker,
-                recipient: params.taker,
-                makerToken: IERC20TokenV06(params.order.makerToken),
-                takerToken: IERC20TokenV06(params.order.takerToken),
-                makerAmount: params.order.makerAmount,
-                takerAmount: params.order.takerAmount,
-                takerTokenFillAmount: params.takerTokenFillAmount,
-                takerTokenFilledAmount: orderInfo.takerTokenFilledAmount
-            })
-        );
-
-        // Pay the fee recipient.
-        if (params.order.takerTokenFeeAmount > 0) {
-            results.takerTokenFeeFilledAmount = uint128(
-                LibMathV06.getPartialAmountFloor(
-                    results.takerTokenFilledAmount,
-                    params.order.takerAmount,
-                    params.order.takerTokenFeeAmount
-                )
-            );
-            _transferERC20TokensFrom(
-                params.order.takerToken,
-                params.taker,
-                params.order.feeRecipient,
-                uint256(results.takerTokenFeeFilledAmount)
-            );
-        }
-
-        emit LimitOrderFilled(
-            orderInfo.orderHash,
-            params.order.maker,
-            params.taker,
-            params.order.feeRecipient,
-            address(params.order.makerToken),
-            address(params.order.takerToken),
-            results.takerTokenFilledAmount,
-            results.makerTokenFilledAmount,
-            results.takerTokenFeeFilledAmount,
-            results.ethProtocolFeePaid,
-            params.order.pool
-        );
-    }
-
-    /// @dev Fill an RFQ order. Private variant.
-    /// @param params Function params.
-    /// @return results Results of the fill.
-    function _fillRfqOrderPrivate(
-        FillRfqOrderPrivateParams memory params
-    ) private returns (FillNativeOrderResults memory results) {
-        LibNativeOrder.OrderInfo memory orderInfo = getRfqOrderInfo(params.order);
-
-        // Must be fillable.
-        if (orderInfo.status != LibNativeOrder.OrderStatus.FILLABLE) {
-            LibNativeOrdersRichErrors.OrderNotFillableError(orderInfo.orderHash, uint8(orderInfo.status)).rrevert();
-        }
-
-        {
-            LibNativeOrdersStorage.Storage storage stor = LibNativeOrdersStorage.getStorage();
-
-            // Must be fillable by the tx.origin.
-            if (params.order.txOrigin != tx.origin && !stor.originRegistry[params.order.txOrigin][tx.origin]) {
-                LibNativeOrdersRichErrors
-                    .OrderNotFillableByOriginError(orderInfo.orderHash, tx.origin, params.order.txOrigin)
-                    .rrevert();
-            }
-        }
-
-        // Must be fillable by the taker.
-        if (params.order.taker != address(0) && params.order.taker != params.taker) {
-            LibNativeOrdersRichErrors
-                .OrderNotFillableByTakerError(orderInfo.orderHash, params.taker, params.order.taker)
-                .rrevert();
-        }
-
-        // Signature must be valid for the order.
-        {
-            address signer = LibSignature.getSignerOfHash(orderInfo.orderHash, params.signature);
-            if (signer != params.order.maker && !isValidOrderSigner(params.order.maker, signer)) {
-                LibNativeOrdersRichErrors
-                    .OrderNotSignedByMakerError(orderInfo.orderHash, signer, params.order.maker)
-                    .rrevert();
-            }
-        }
-
-        // Settle between the maker and taker.
-        (results.takerTokenFilledAmount, results.makerTokenFilledAmount) = _settleOrder(
-            SettleOrderInfo({
-                orderHash: orderInfo.orderHash,
-                maker: params.order.maker,
-                payer: params.useSelfBalance ? address(this) : params.taker,
-                recipient: params.recipient,
-                makerToken: IERC20TokenV06(params.order.makerToken),
-                takerToken: IERC20TokenV06(params.order.takerToken),
-                makerAmount: params.order.makerAmount,
-                takerAmount: params.order.takerAmount,
-                takerTokenFillAmount: params.takerTokenFillAmount,
-                takerTokenFilledAmount: orderInfo.takerTokenFilledAmount
-            })
-        );
-
-        emit RfqOrderFilled(
-            orderInfo.orderHash,
-            params.order.maker,
-            params.taker,
-            address(params.order.makerToken),
-            address(params.order.takerToken),
-            results.takerTokenFilledAmount,
-            results.makerTokenFilledAmount,
-            params.order.pool
-        );
-    }
-
-    /// @dev Settle the trade between an order's maker and taker.
-    /// @param settleInfo Information needed to execute the settlement.
-    /// @return takerTokenFilledAmount How much taker token was filled.
-    /// @return makerTokenFilledAmount How much maker token was filled.
-    function _settleOrder(
-        SettleOrderInfo memory settleInfo
-    ) private returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
-        // Clamp the taker token fill amount to the fillable amount.
-        takerTokenFilledAmount = LibSafeMathV06.min128(
-            settleInfo.takerTokenFillAmount,
-            settleInfo.takerAmount.safeSub128(settleInfo.takerTokenFilledAmount)
-        );
-        // Compute the maker token amount.
-        // This should never overflow because the values are all clamped to
-        // (2^128-1).
-        makerTokenFilledAmount = uint128(
-            LibMathV06.getPartialAmountFloor(
-                uint256(takerTokenFilledAmount),
-                uint256(settleInfo.takerAmount),
-                uint256(settleInfo.makerAmount)
-            )
-        );
-
-        if (takerTokenFilledAmount == 0 || makerTokenFilledAmount == 0) {
-            // Nothing to do.
-            return (0, 0);
-        }
-
-        // Update filled state for the order.
-        // solhint-disable-next-line max-line-length
-        LibNativeOrdersStorage.getStorage().orderHashToTakerTokenFilledAmount[settleInfo.orderHash] = settleInfo // function if the order is cancelled. // OK to overwrite the whole word because we shouldn't get to this
-            .takerTokenFilledAmount
-            .safeAdd128(takerTokenFilledAmount);
-
-        if (settleInfo.payer == address(this)) {
-            // Transfer this -> maker.
-            _transferERC20Tokens(settleInfo.takerToken, settleInfo.maker, takerTokenFilledAmount);
-        } else {
-            // Transfer taker -> maker.
-            _transferERC20TokensFrom(settleInfo.takerToken, settleInfo.payer, settleInfo.maker, takerTokenFilledAmount);
-        }
-
-        // Transfer maker -> recipient.
-        _transferERC20TokensFrom(settleInfo.makerToken, settleInfo.maker, settleInfo.recipient, makerTokenFilledAmount);
-    }
-
-    /// @dev register a signer who can sign on behalf of msg.sender
-    /// @param signer The address from which you plan to generate signatures
-    /// @param allowed True to register, false to unregister.
-    function registerAllowedOrderSigner(address signer, bool allowed) external {
-        LibNativeOrdersStorage.Storage storage stor = LibNativeOrdersStorage.getStorage();
-
-        stor.orderSignerRegistry[msg.sender][signer] = allowed;
-
-        emit OrderSignerRegistered(msg.sender, signer, allowed);
-    }
+abstract contract NativeOrdersSettlement is INativeOrdersEvents, NativeOrdersCancellation, NativeOrdersProtocolFees, FixinCommon {
+	using LibSafeMathV06 for uint128;
+	using LibRichErrorsV06 for bytes;
+
+	/// @dev Params for `_settleOrder()`.
+	struct SettleOrderInfo {
+		// Order hash.
+		bytes32 orderHash;
+		// Maker of the order.
+		address maker;
+		// The address holding the taker tokens.
+		address payer;
+		// Recipient of the maker tokens.
+		address recipient;
+		// Maker token.
+		IERC20TokenV06 makerToken;
+		// Taker token.
+		IERC20TokenV06 takerToken;
+		// Maker token amount.
+		uint128 makerAmount;
+		// Taker token amount.
+		uint128 takerAmount;
+		// Maximum taker token amount to fill.
+		uint128 takerTokenFillAmount;
+		// How much taker token amount has already been filled in this order.
+		uint128 takerTokenFilledAmount;
+	}
+
+	/// @dev Params for `_fillLimitOrderPrivate()`
+	struct FillLimitOrderPrivateParams {
+		// The limit order.
+		LibNativeOrder.LimitOrder order;
+		// The order signature.
+		LibSignature.Signature signature;
+		// Maximum taker token to fill this order with.
+		uint128 takerTokenFillAmount;
+		// The order taker.
+		address taker;
+		// The order sender.
+		address sender;
+	}
+
+	/// @dev Params for `_fillRfqOrderPrivate()`
+	struct FillRfqOrderPrivateParams {
+		LibNativeOrder.RfqOrder order;
+		// The order signature.
+		LibSignature.Signature signature;
+		// Maximum taker token to fill this order with.
+		uint128 takerTokenFillAmount;
+		// The order taker.
+		address taker;
+		// Whether to use the Exchange Proxy's balance
+		// of taker tokens.
+		bool useSelfBalance;
+		// The recipient of the maker tokens.
+		address recipient;
+	}
+
+	// @dev Fill results returned by `_fillLimitOrderPrivate()` and
+	///     `_fillRfqOrderPrivate()`.
+	struct FillNativeOrderResults {
+		uint256 ethProtocolFeePaid;
+		uint128 takerTokenFilledAmount;
+		uint128 makerTokenFilledAmount;
+		uint128 takerTokenFeeFilledAmount;
+	}
+
+	constructor(
+		address zeroExAddress,
+		IEtherTokenV06 weth,
+		IStaking staking,
+		FeeCollectorController feeCollectorController,
+		uint32 protocolFeeMultiplier
+	) public NativeOrdersCancellation(zeroExAddress) NativeOrdersProtocolFees(weth, staking, feeCollectorController, protocolFeeMultiplier) {}
+
+	/// @dev Fill a limit order. The taker and sender will be the caller.
+	/// @param order The limit order. ETH protocol fees can be
+	///      attached to this call. Any unspent ETH will be refunded to
+	///      the caller.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount Maximum taker token amount to fill this order with.
+	/// @return takerTokenFilledAmount How much maker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function fillLimitOrder(
+		LibNativeOrder.LimitOrder memory order,
+		LibSignature.Signature memory signature,
+		uint128 takerTokenFillAmount
+	) public payable returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
+		FillNativeOrderResults memory results = _fillLimitOrderPrivate(
+			FillLimitOrderPrivateParams({
+				order: order,
+				signature: signature,
+				takerTokenFillAmount: takerTokenFillAmount,
+				taker: msg.sender,
+				sender: msg.sender
+			})
+		);
+		LibNativeOrder.refundExcessProtocolFeeToSender(results.ethProtocolFeePaid);
+		(takerTokenFilledAmount, makerTokenFilledAmount) = (results.takerTokenFilledAmount, results.makerTokenFilledAmount);
+	}
+
+	/// @dev Fill an RFQ order for up to `takerTokenFillAmount` taker tokens.
+	///      The taker will be the caller. ETH should be attached to pay the
+	///      protocol fee.
+	/// @param order The RFQ order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount Maximum taker token amount to fill this order with.
+	/// @return takerTokenFilledAmount How much maker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function fillRfqOrder(
+		LibNativeOrder.RfqOrder memory order,
+		LibSignature.Signature memory signature,
+		uint128 takerTokenFillAmount
+	) public returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
+		FillNativeOrderResults memory results = _fillRfqOrderPrivate(
+			FillRfqOrderPrivateParams({
+				order: order,
+				signature: signature,
+				takerTokenFillAmount: takerTokenFillAmount,
+				taker: msg.sender,
+				useSelfBalance: false,
+				recipient: msg.sender
+			})
+		);
+		(takerTokenFilledAmount, makerTokenFilledAmount) = (results.takerTokenFilledAmount, results.makerTokenFilledAmount);
+	}
+
+	/// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.
+	///      The taker will be the caller. ETH protocol fees can be
+	///      attached to this call. Any unspent ETH will be refunded to
+	///      the caller.
+	/// @param order The limit order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount How much taker token to fill this order with.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function fillOrKillLimitOrder(
+		LibNativeOrder.LimitOrder memory order,
+		LibSignature.Signature memory signature,
+		uint128 takerTokenFillAmount
+	) public payable returns (uint128 makerTokenFilledAmount) {
+		FillNativeOrderResults memory results = _fillLimitOrderPrivate(
+			FillLimitOrderPrivateParams({
+				order: order,
+				signature: signature,
+				takerTokenFillAmount: takerTokenFillAmount,
+				taker: msg.sender,
+				sender: msg.sender
+			})
+		);
+		// Must have filled exactly the amount requested.
+		if (results.takerTokenFilledAmount < takerTokenFillAmount) {
+			LibNativeOrdersRichErrors.FillOrKillFailedError(getLimitOrderHash(order), results.takerTokenFilledAmount, takerTokenFillAmount).rrevert();
+		}
+		LibNativeOrder.refundExcessProtocolFeeToSender(results.ethProtocolFeePaid);
+		makerTokenFilledAmount = results.makerTokenFilledAmount;
+	}
+
+	/// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.
+	///      The taker will be the caller. ETH protocol fees can be
+	///      attached to this call. Any unspent ETH will be refunded to
+	///      the caller.
+	/// @param order The RFQ order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount How much taker token to fill this order with.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function fillOrKillRfqOrder(
+		LibNativeOrder.RfqOrder memory order,
+		LibSignature.Signature memory signature,
+		uint128 takerTokenFillAmount
+	) public returns (uint128 makerTokenFilledAmount) {
+		FillNativeOrderResults memory results = _fillRfqOrderPrivate(
+			FillRfqOrderPrivateParams({
+				order: order,
+				signature: signature,
+				takerTokenFillAmount: takerTokenFillAmount,
+				taker: msg.sender,
+				useSelfBalance: false,
+				recipient: msg.sender
+			})
+		);
+		// Must have filled exactly the amount requested.
+		if (results.takerTokenFilledAmount < takerTokenFillAmount) {
+			LibNativeOrdersRichErrors.FillOrKillFailedError(getRfqOrderHash(order), results.takerTokenFilledAmount, takerTokenFillAmount).rrevert();
+		}
+		makerTokenFilledAmount = results.makerTokenFilledAmount;
+	}
+
+	/// @dev Fill a limit order. Internal variant. ETH protocol fees can be
+	///      attached to this call.
+	/// @param order The limit order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount Maximum taker token to fill this order with.
+	/// @param taker The order taker.
+	/// @param sender The order sender.
+	/// @return takerTokenFilledAmount How much maker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function _fillLimitOrder(
+		LibNativeOrder.LimitOrder memory order,
+		LibSignature.Signature memory signature,
+		uint128 takerTokenFillAmount,
+		address taker,
+		address sender
+	) public payable virtual onlySelf returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
+		FillNativeOrderResults memory results = _fillLimitOrderPrivate(FillLimitOrderPrivateParams(order, signature, takerTokenFillAmount, taker, sender));
+		(takerTokenFilledAmount, makerTokenFilledAmount) = (results.takerTokenFilledAmount, results.makerTokenFilledAmount);
+	}
+
+	/// @dev Fill an RFQ order. Internal variant.
+	/// @param order The RFQ order.
+	/// @param signature The order signature.
+	/// @param takerTokenFillAmount Maximum taker token to fill this order with.
+	/// @param taker The order taker.
+	/// @param useSelfBalance Whether to use the ExchangeProxy's transient
+	///        balance of taker tokens to fill the order.
+	/// @param recipient The recipient of the maker tokens.
+	/// @return takerTokenFilledAmount How much maker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function _fillRfqOrder(
+		LibNativeOrder.RfqOrder memory order,
+		LibSignature.Signature memory signature,
+		uint128 takerTokenFillAmount,
+		address taker,
+		bool useSelfBalance,
+		address recipient
+	) public virtual onlySelf returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
+		FillNativeOrderResults memory results = _fillRfqOrderPrivate(
+			FillRfqOrderPrivateParams(order, signature, takerTokenFillAmount, taker, useSelfBalance, recipient)
+		);
+		(takerTokenFilledAmount, makerTokenFilledAmount) = (results.takerTokenFilledAmount, results.makerTokenFilledAmount);
+	}
+
+	/// @dev Mark what tx.origin addresses are allowed to fill an order that
+	///      specifies the message sender as its txOrigin.
+	/// @param origins An array of origin addresses to update.
+	/// @param allowed True to register, false to unregister.
+	function registerAllowedRfqOrigins(address[] calldata origins, bool allowed) external {
+		require(msg.sender == tx.origin, "NativeOrdersFeature/NO_CONTRACT_ORIGINS");
+
+		LibNativeOrdersStorage.Storage storage stor = LibNativeOrdersStorage.getStorage();
+
+		for (uint256 i = 0; i < origins.length; i++) {
+			stor.originRegistry[msg.sender][origins[i]] = allowed;
+		}
+
+		emit RfqOrderOriginsAllowed(msg.sender, origins, allowed);
+	}
+
+	/// @dev Fill a limit order. Private variant. Does not refund protocol fees.
+	/// @param params Function params.
+	/// @return results Results of the fill.
+	function _fillLimitOrderPrivate(FillLimitOrderPrivateParams memory params) private returns (FillNativeOrderResults memory results) {
+		LibNativeOrder.OrderInfo memory orderInfo = getLimitOrderInfo(params.order);
+
+		// Must be fillable.
+		if (orderInfo.status != LibNativeOrder.OrderStatus.FILLABLE) {
+			LibNativeOrdersRichErrors.OrderNotFillableError(orderInfo.orderHash, uint8(orderInfo.status)).rrevert();
+		}
+
+		// Must be fillable by the taker.
+		if (params.order.taker != address(0) && params.order.taker != params.taker) {
+			LibNativeOrdersRichErrors.OrderNotFillableByTakerError(orderInfo.orderHash, params.taker, params.order.taker).rrevert();
+		}
+
+		// Must be fillable by the sender.
+		if (params.order.sender != address(0) && params.order.sender != params.sender) {
+			LibNativeOrdersRichErrors.OrderNotFillableBySenderError(orderInfo.orderHash, params.sender, params.order.sender).rrevert();
+		}
+
+		// Signature must be valid for the order.
+		{
+			address signer = LibSignature.getSignerOfHash(orderInfo.orderHash, params.signature);
+			if (signer != params.order.maker && !isValidOrderSigner(params.order.maker, signer)) {
+				LibNativeOrdersRichErrors.OrderNotSignedByMakerError(orderInfo.orderHash, signer, params.order.maker).rrevert();
+			}
+		}
+
+		// Pay the protocol fee.
+		results.ethProtocolFeePaid = _collectProtocolFee(params.order.pool);
+
+		// Settle between the maker and taker.
+		(results.takerTokenFilledAmount, results.makerTokenFilledAmount) = _settleOrder(
+			SettleOrderInfo({
+				orderHash: orderInfo.orderHash,
+				maker: params.order.maker,
+				payer: params.taker,
+				recipient: params.taker,
+				makerToken: IERC20TokenV06(params.order.makerToken),
+				takerToken: IERC20TokenV06(params.order.takerToken),
+				makerAmount: params.order.makerAmount,
+				takerAmount: params.order.takerAmount,
+				takerTokenFillAmount: params.takerTokenFillAmount,
+				takerTokenFilledAmount: orderInfo.takerTokenFilledAmount
+			})
+		);
+
+		// Pay the fee recipient.
+		if (params.order.takerTokenFeeAmount > 0) {
+			results.takerTokenFeeFilledAmount = uint128(
+				LibMathV06.getPartialAmountFloor(results.takerTokenFilledAmount, params.order.takerAmount, params.order.takerTokenFeeAmount)
+			);
+			_transferERC20TokensFrom(params.order.takerToken, params.taker, params.order.feeRecipient, uint256(results.takerTokenFeeFilledAmount));
+		}
+
+		emit LimitOrderFilled(
+			orderInfo.orderHash,
+			params.order.maker,
+			params.taker,
+			params.order.feeRecipient,
+			address(params.order.makerToken),
+			address(params.order.takerToken),
+			results.takerTokenFilledAmount,
+			results.makerTokenFilledAmount,
+			results.takerTokenFeeFilledAmount,
+			results.ethProtocolFeePaid,
+			params.order.pool
+		);
+	}
+
+	/// @dev Fill an RFQ order. Private variant.
+	/// @param params Function params.
+	/// @return results Results of the fill.
+	function _fillRfqOrderPrivate(FillRfqOrderPrivateParams memory params) private returns (FillNativeOrderResults memory results) {
+		LibNativeOrder.OrderInfo memory orderInfo = getRfqOrderInfo(params.order);
+
+		// Must be fillable.
+		if (orderInfo.status != LibNativeOrder.OrderStatus.FILLABLE) {
+			LibNativeOrdersRichErrors.OrderNotFillableError(orderInfo.orderHash, uint8(orderInfo.status)).rrevert();
+		}
+
+		{
+			LibNativeOrdersStorage.Storage storage stor = LibNativeOrdersStorage.getStorage();
+
+			// Must be fillable by the tx.origin.
+			if (params.order.txOrigin != tx.origin && !stor.originRegistry[params.order.txOrigin][tx.origin]) {
+				LibNativeOrdersRichErrors.OrderNotFillableByOriginError(orderInfo.orderHash, tx.origin, params.order.txOrigin).rrevert();
+			}
+		}
+
+		// Must be fillable by the taker.
+		if (params.order.taker != address(0) && params.order.taker != params.taker) {
+			LibNativeOrdersRichErrors.OrderNotFillableByTakerError(orderInfo.orderHash, params.taker, params.order.taker).rrevert();
+		}
+
+		// Signature must be valid for the order.
+		{
+			address signer = LibSignature.getSignerOfHash(orderInfo.orderHash, params.signature);
+			if (signer != params.order.maker && !isValidOrderSigner(params.order.maker, signer)) {
+				LibNativeOrdersRichErrors.OrderNotSignedByMakerError(orderInfo.orderHash, signer, params.order.maker).rrevert();
+			}
+		}
+
+		// Settle between the maker and taker.
+		(results.takerTokenFilledAmount, results.makerTokenFilledAmount) = _settleOrder(
+			SettleOrderInfo({
+				orderHash: orderInfo.orderHash,
+				maker: params.order.maker,
+				payer: params.useSelfBalance ? address(this) : params.taker,
+				recipient: params.recipient,
+				makerToken: IERC20TokenV06(params.order.makerToken),
+				takerToken: IERC20TokenV06(params.order.takerToken),
+				makerAmount: params.order.makerAmount,
+				takerAmount: params.order.takerAmount,
+				takerTokenFillAmount: params.takerTokenFillAmount,
+				takerTokenFilledAmount: orderInfo.takerTokenFilledAmount
+			})
+		);
+
+		emit RfqOrderFilled(
+			orderInfo.orderHash,
+			params.order.maker,
+			params.taker,
+			address(params.order.makerToken),
+			address(params.order.takerToken),
+			results.takerTokenFilledAmount,
+			results.makerTokenFilledAmount,
+			params.order.pool
+		);
+	}
+
+	/// @dev Settle the trade between an order's maker and taker.
+	/// @param settleInfo Information needed to execute the settlement.
+	/// @return takerTokenFilledAmount How much taker token was filled.
+	/// @return makerTokenFilledAmount How much maker token was filled.
+	function _settleOrder(SettleOrderInfo memory settleInfo) private returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount) {
+		// Clamp the taker token fill amount to the fillable amount.
+		takerTokenFilledAmount = LibSafeMathV06.min128(settleInfo.takerTokenFillAmount, settleInfo.takerAmount.safeSub128(settleInfo.takerTokenFilledAmount));
+		// Compute the maker token amount.
+		// This should never overflow because the values are all clamped to
+		// (2^128-1).
+		makerTokenFilledAmount = uint128(
+			LibMathV06.getPartialAmountFloor(uint256(takerTokenFilledAmount), uint256(settleInfo.takerAmount), uint256(settleInfo.makerAmount))
+		);
+
+		if (takerTokenFilledAmount == 0 || makerTokenFilledAmount == 0) {
+			// Nothing to do.
+			return (0, 0);
+		}
+
+		// Update filled state for the order.
+		// solhint-disable-next-line max-line-length
+		LibNativeOrdersStorage.getStorage().orderHashToTakerTokenFilledAmount[settleInfo.orderHash] = settleInfo.takerTokenFilledAmount.safeAdd128( // function if the order is cancelled. // OK to overwrite the whole word because we shouldn't get to this
+				takerTokenFilledAmount
+			);
+
+		if (settleInfo.payer == address(this)) {
+			// Transfer this -> maker.
+			_transferERC20Tokens(settleInfo.takerToken, settleInfo.maker, takerTokenFilledAmount);
+		} else {
+			// Transfer taker -> maker.
+			_transferERC20TokensFrom(settleInfo.takerToken, settleInfo.payer, settleInfo.maker, takerTokenFilledAmount);
+		}
+
+		// Transfer maker -> recipient.
+		_transferERC20TokensFrom(settleInfo.makerToken, settleInfo.maker, settleInfo.recipient, makerTokenFilledAmount);
+	}
+
+	/// @dev register a signer who can sign on behalf of msg.sender
+	/// @param signer The address from which you plan to generate signatures
+	/// @param allowed True to register, false to unregister.
+	function registerAllowedOrderSigner(address signer, bool allowed) external {
+		LibNativeOrdersStorage.Storage storage stor = LibNativeOrdersStorage.getStorage();
+
+		stor.orderSignerRegistry[msg.sender][signer] = allowed;
+
+		emit OrderSignerRegistered(msg.sender, signer, allowed);
+	}
 }
